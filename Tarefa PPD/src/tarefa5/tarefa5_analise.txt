Tarefa 5 – Análise Crítica e Consolidação dos Conceitos

O desenvolvimento das tarefas propostas permitiu uma compreensão progressiva e prática dos principais conceitos relacionados à programação paralela e concorrente. A partir de um mesmo problema clássico, o Jantar dos Filósofos, foi possível observar tanto os riscos envolvidos no acesso concorrente a recursos compartilhados quanto as diferentes estratégias para controlar esse acesso de forma correta.
Na primeira tarefa, a implementação intencionalmente simples teve como objetivo evidenciar o problema do deadlock. Ao permitir que todos os filósofos adquirissem os garfos na mesma ordem, foi possível observar na prática a ocorrência da espera circular e o travamento completo do sistema. Essa abordagem, apesar de inadequada para sistemas reais, foi fundamental para compreender as condições necessárias para que o deadlock ocorra
Na segunda tarefa, o problema do deadlock foi tratado por meio da quebra da condição de espera circular, alterando a ordem de aquisição dos recursos para apenas um dos filósofos. Essa solução mostrou que pequenas mudanças na lógica de sincronização podem ter grande impacto no comportamento do sistema. Apesar de eliminar o deadlock, a implementação ainda pode apresentar starvation, evidenciando que a ausência de deadlock não garante justiça no acesso aos recursos.
A terceira tarefa introduziu o uso de semáforos, permitindo um controle mais explícito sobre os recursos compartilhados. Cada garfo passou a ser protegido por um semáforo binário, garantindo exclusão mútua e evitando condições de corrida. Essa abordagem reforçou a importância de mecanismos clássicos de sincronização e demonstrou como o uso correto de semáforos pode manter o sistema em execução contínua, embora ainda exija cuidado para evitar problemas como starvation.
Na quarta tarefa, a utilização de um monitor centralizou toda a lógica de sincronização em uma única estrutura, responsável por gerenciar o acesso aos garfos. Essa solução se mostrou mais organizada e robusta, pois elimina o deadlock e reduz significativamente a possibilidade de starvation, além de facilitar a manutenção e o entendimento do código. A separação clara das responsabilidades também contribuiu para uma implementação mais limpa e coerente.
De forma geral, observa-se uma evolução clara tanto na complexidade das soluções quanto na compreensão dos conceitos envolvidos. Cada exercício foi projetado para destacar um aspecto específico da programação concorrente, permitindo que o aprendizado ocorresse de maneira incremental e prática. A execução dos programas e a análise de seus comportamentos reforçaram conceitos teóricos como exclusão mútua, sincronização, deadlock e starvation.